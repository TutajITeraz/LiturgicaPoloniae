<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js Points with Distance Measurement</title>
    <script async src="https://cdn.jsdelivr.net/npm/es-module-shims@1.8.3/dist/es-module-shims.min.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.166.1/build/three.module.min.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/"
        }
      }
    </script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #111;
        font-family: Arial, sans-serif;
      }
      canvas {
        display: block;
      }
      /* Label styling */
      .point-label {
        position: absolute;
        color: white;
        font-family: sans-serif;
        padding: 2px 5px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 4px;
        pointer-events: none;
        white-space: nowrap;
        font-size: 14px;
        transform: translate(-50%, -100%);
        z-index: 100;
      }
      /* Formula styling */
      .formula-text {
        position: absolute;
        left: 10px;
        bottom: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        width: 45%;
        max-height: 30%;
        overflow-y: auto;
        font-size: 14px;
        z-index: 100;
        display: none;
      }
      /* Selected point text styling */
      .selected-point-text {
        position: absolute;
        right: 10px;
        bottom: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        width: 45%;
        max-height: 30%;
        overflow-y: auto;
        font-size: 14px;
        z-index: 100;
        display: none;
      }

      /* Distance display styling */
      .distance-display {
        position: absolute;
        top: 5%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 14px;
        pointer-events: none;
        z-index: 100;
        display: none;
      }
      /* Highlight differences */
      .different-text {
        color: #5cffaf; /* Light green for different text */
      }
      /* Distance display styling - now integrated with formula text */
      .distance-info {
        margin-top: 8px;
        padding-top: 5px;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
        color: #ffcc00; /* Yellow for distance */
      }
      /* File input styling */
      .file-inputs {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 10;
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 4px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .file-input-group {
        display: flex;
        flex-direction: column;
      }
      label {
        margin-bottom: 3px;
        font-size: 14px;
      }
      /* Controls Help */
      .controls-help {
        position: absolute;
        right: 10px;
        top: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 14px;
        z-index: 100;
      }
      /* Render Options */
      .render-options {
        position: absolute;
        right: 10px;
        top: 20px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 14px;
        z-index: 100;
      }
      /* Loading message */
      .loading-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        font-size: 16px;
        z-index: 1000;
      }
    </style>
  </head>
  <body>
    <div class="file-inputs">
      <div class="file-input-group">
        <label for="csvInput">Upload Points CSV:</label>
        <input type="file" id="csvInput" accept=".csv" />
      </div>
      <div class="file-input-group">
        <label for="formulasInput">Upload Formulas CSV (optional):</label>
        <input type="file" id="formulasInput" accept=".csv" />
      </div>
    </div>
    <div class="formula-text" id="formulaText"></div>
    <div class="selected-point-text" id="selectedPointText"></div>
    <div class="distance-display" id="distanceDisplay"></div>
    <div id="loadingMessage" class="loading-message">Loading default data...</div>

    <div class="controls-help">
      <p><strong>Controls:</strong></p>
      <p>Pan: Middle mouse or Shift+Left click</p>
      <p>Keyboard: Arrow keys</p>
      <p>Orbit: Left mouse</p>
      <p>Zoom: Scroll wheel</p>
      <p>Click on point: Pin info to right panel</p>
      <p>Hover over point: See distance from selected point</p>
    </div>
    <div class="render-options">
      <label>
        <input type="checkbox" id="renderAsSpheres" /> Render as Spheres
      </label>
    </div>
    
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";

      // --- Constants ---
      const RENDER_AS_SPHERES = true; // Default rendering mode
      const SPHERE_SIZE = 0.35; // Size of the spheres representing each point
      const hoverColor = new THREE.Color("white");
      const selectedColor = new THREE.Color("cyan");
      const lineColor = new THREE.Color("yellow");
      const DEFAULT_POINTS_URL = "/static/formulas_visualizer/data/coordinates_hdbscan.csv";
      const DEFAULT_FORMULAS_URL = "/static/formulas_visualizer/data/formulas.csv";

      // --- Scene, Camera, Renderer Setup ---
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 0, 40);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.enablePan = true;
      controls.keyPanSpeed = 10; // Increase keyboard pan speed
      controls.screenSpacePanning = true; // Makes panning more intuitive

      // --- Create a Label Div ---
      const labelDiv = document.createElement("div");
      labelDiv.className = "point-label";
      labelDiv.style.display = "none";
      document.body.appendChild(labelDiv);

      // --- Formula Text Display ---
      const formulaTextDiv = document.getElementById("formulaText");
      
      // --- Selected Point Text Display ---
      const selectedPointTextDiv = document.getElementById("selectedPointText");

      // --- Distance Display ---
      const distanceDisplayDiv = document.getElementById("distanceDisplay");
      
      // --- Loading Message ---
      const loadingMessageDiv = document.getElementById("loadingMessage");

      // --- Global Variables for Points Data ---
      let pointData;
      let count = 0;
      const defaultColor = new THREE.Color("orange");
      let formulasData = null;
      let renderAsSpheres = RENDER_AS_SPHERES;
      let selectedPointId = null;
      let selectedPointIndex = -1;
      let selectedPointPosition = null;
      let hoverPointPosition = null;
      
      // --- Line Between Points ---
      const lineMaterial = new THREE.LineBasicMaterial({ color: lineColor });
      const lineGeometry = new THREE.BufferGeometry();
      const linePoints = [
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 0, 0)
      ];
      lineGeometry.setFromPoints(linePoints);
      const distanceLine = new THREE.Line(lineGeometry, lineMaterial);
      distanceLine.visible = false;
      scene.add(distanceLine);
      
      // --- Geometries Setup ---
      const planeSize = 0.5; // Size of the plane representing each point
      const planeGeometry = new THREE.PlaneGeometry(planeSize, planeSize);
      // Low-poly sphere (icosahedron with 1 subdivision)
      const sphereGeometry = new THREE.IcosahedronGeometry(SPHERE_SIZE / 2, 1);
      
      // Material for both planes and spheres
      const instanceMaterial = new THREE.MeshBasicMaterial({
        side: THREE.DoubleSide,
        vertexColors: false,
        transparent: true,
        depthWrite: true
      });
      
      // Create a matrix for each instance
      const matrix = new THREE.Matrix4();
      let instancedMesh;
      let colorArray; // Array to store original colors for each instance
      
      // Create the instance mesh with 0 instances initially (we'll update it later)
      instancedMesh = new THREE.InstancedMesh(planeGeometry, instanceMaterial, 0);
      instancedMesh.computeBoundingSphere();
      instancedMesh.computeBoundingBox();
      scene.add(instancedMesh);

      // --- Raycaster Setup ---
      const raycaster = new THREE.Raycaster();
      raycaster.params.Points.threshold = 1;
      const pointer = new THREE.Vector2();
      let prevHoverIndex = -1;

      // --- CSV Parser ---
      function parseCSV(text) {
        const lines = text.split('\n');
        const headers = parseCSVLine(lines[0]);
        
        const result = [];
        for (let i = 1; i < lines.length; i++) {
          if (lines[i].trim() === '') continue;
          
          const values = parseCSVLine(lines[i]);
          const entry = {};
          
          for (let j = 0; j < headers.length; j++) {
            entry[headers[j]] = values[j];
          }
          
          result.push(entry);
        }
        
        return result;
      }

      function parseCSVLine(line) {
        line = line.replace(/(\r\n|\n|\r)/gm, "");

        const result = [];
        let inQuotes = false;
        let currentEntry = '';
        
        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          
          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === ',' && !inQuotes) {
            // Remove quotes if they're around the entire value
            if (currentEntry.startsWith('"') && currentEntry.endsWith('"')) {
              currentEntry = currentEntry.substring(1, currentEntry.length - 1);
            }
            result.push(currentEntry);
            currentEntry = '';
          } else {
            currentEntry += char;
          }
        }
        
        // Add the last entry
        if (currentEntry) {
          if (currentEntry.startsWith('"') && currentEntry.endsWith('"')) {
            currentEntry = currentEntry.substring(1, currentEntry.length - 1);
          }
          result.push(currentEntry);
        }
        
        return result;
      }

      // Function to highlight differences between formula and selected point text
      function markTextDifferences(text1, text2) {
        if (!text1 || !text2) return { text1: text1 || "", text2: text2 || "" };
        
        // Simple word-by-word comparison
        const words1 = text1.split(/\s+/);
        const words2 = text2.split(/\s+/);
        
        let result1 = "";
        let result2 = "";
        
        // Find the maximum length of both arrays
        const maxLength = Math.max(words1.length, words2.length);
        
        for (let i = 0; i < maxLength; i++) {
          const word1 = i < words1.length ? words1[i] : "";
          const word2 = i < words2.length ? words2[i] : "";
          
          if (word1 !== word2) {
            result1 += i < words1.length ? `<span class="different-text">${word1}</span> ` : "";
            result2 += i < words2.length ? `<span class="different-text">${word2}</span> ` : "";
          } else {
            result1 += word1 + " ";
            result2 += word2 + " ";
          }
        }
        
        return { text1: result1.trim(), text2: result2.trim() };
      }

      // Function to update label position and content
      function updateLabel(index) {
        if (!pointData || index >= pointData.length) return;
        
        const point = pointData[index];
        labelDiv.textContent = point.id;
        
        // Get position from instancedMesh's matrix
        const matrix = new THREE.Matrix4();
        instancedMesh.getMatrixAt(index, matrix);
        const position = new THREE.Vector3();
        position.setFromMatrixPosition(matrix);
        
        // Store hover point position for distance calculation
        hoverPointPosition = position.clone();
        
        // Update distance line and display if there's a selected point
        updateDistanceLineAndDisplay();
        
        // Convert 3D point to screen coordinates
        const vector = position.clone();
        vector.project(camera);
        
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        
        labelDiv.style.left = `${x}px`;
        labelDiv.style.top = `${y}px`;
        labelDiv.style.display = "block";
        
        // Show formula text if available
        if (formulasData && point.id) {
          const formula = formulasData.find(f => f.id === point.id);
          
          // Get selected point formula for comparison if any
          let selectedFormula = null;
          if (selectedPointId) {
            selectedFormula = formulasData.find(f => f.id === selectedPointId);
          }
          
          if (formula) {
            let formulaText = formula.text || '';
            
            // Add distance information if selected point exists
            if (selectedPointPosition && hoverPointPosition) {
              const distance = selectedPointPosition.distanceTo(hoverPointPosition);
              formulaText += `<div class="distance-info">Distance: ${distance.toFixed(2)}</div>`;
            }
            
            // If there's a selected point with formula, highlight differences
            if (selectedFormula && selectedFormula.text) {
              const highlighted = markTextDifferences(formula.text, selectedFormula.text);
              formulaText = highlighted.text1;
              
              // Update the selected point text with highlighted differences
              selectedPointTextDiv.innerHTML = `<strong>${selectedPointId}</strong><br><br>${highlighted.text2}`;
            }
            
            formulaTextDiv.innerHTML = `<strong>${point.id}</strong><br><br>${formulaText}`;
            formulaTextDiv.style.display = "block";
          } else {
            formulaTextDiv.style.display = "none";
          }
        }
      }

      // Function to update the selected point text display
      function updateSelectedPointDisplay() {
        if (!selectedPointId || !formulasData) {
          selectedPointTextDiv.style.display = "none";
          return;
        }
        
        const formula = formulasData.find(f => f.id === selectedPointId);
        if (formula) {
          // Display a header with the point ID and the formula text
          selectedPointTextDiv.innerHTML = `<strong>${selectedPointId}</strong><br><br>${formula.text || ''}`;
          selectedPointTextDiv.style.display = "block";
          
          // If there's a currently hovered point with formula, update to show differences
          if (hoverPointPosition && prevHoverIndex !== -1 && pointData) {
            const hoveredPointId = pointData[prevHoverIndex].id;
            const hoveredFormula = formulasData.find(f => f.id === hoveredPointId);
            
            if (hoveredFormula && hoveredFormula.text) {
              const highlighted = markTextDifferences(hoveredFormula.text, formula.text);
              
              // Update both displays
              formulaTextDiv.innerHTML = `<strong>${hoveredPointId}</strong><br><br>${highlighted.text1}`;
              selectedPointTextDiv.innerHTML = `<strong>${selectedPointId}</strong><br><br>${highlighted.text2}`;
              
              // Add distance information to the formula text
              if (selectedPointPosition && hoverPointPosition) {
                const distance = selectedPointPosition.distanceTo(hoverPointPosition);
                formulaTextDiv.innerHTML += `<div class="distance-info">Distance: ${distance.toFixed(2)}</div>`;
              }
            }
          }
        } else {
          selectedPointTextDiv.style.display = "none";
        }
      }

      // Function to update the distance line and display
      // Function to update the distance line and display
      function updateDistanceLineAndDisplay() {
        if (selectedPointPosition && hoverPointPosition) {
          // Update line geometry
          linePoints[0].copy(selectedPointPosition);
          linePoints[1].copy(hoverPointPosition);
          lineGeometry.setFromPoints(linePoints);
          distanceLine.visible = true;
          
          // Calculate distance
          const distance = selectedPointPosition.distanceTo(hoverPointPosition);
          
          // Update display
          distanceDisplayDiv.textContent = `Distance: ${distance.toFixed(2)}`;
          
          // Calculate midpoint for distance display position
          const midPoint = new THREE.Vector3().addVectors(
            selectedPointPosition, 
            hoverPointPosition
          ).multiplyScalar(0.5);
          
          // Project to screen space
          const vector = midPoint.clone();
          vector.project(camera);
          
          const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
          const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
          
          //distanceDisplayDiv.style.left = `${x}px`;
          //distanceDisplayDiv.style.top = `${y}px`;
          distanceDisplayDiv.style.display = "block";
        } else {
          // Hide line and distance display if we don't have both points
          distanceLine.visible = false;
          distanceDisplayDiv.style.display = "none";
        }
      }

      // --- Pointer Move Handler for Hover ---
      function onPointerMove(event) {
        event.preventDefault();
        
        // Update pointer coordinates
        pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
        pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        // Check for intersections
        checkIntersections();
      }

      // --- Click Handler for Point Selection ---
      function onPointerDown(event) {
        // Only process left clicks
        if (event.button !== 0) return;
        
        event.preventDefault();
        
        // Update pointer coordinates
        pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
        pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        // Perform raycasting
        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObject(instancedMesh);
        
        if (intersects.length > 0) {
          // Get the instance index
          const index = intersects[0].instanceId;
          
          // Get the point ID
          if (pointData && index < pointData.length) {
            const pointId = pointData[index].id;
            
            // Reset previous selected point color
            if (selectedPointIndex !== -1 && selectedPointIndex < instancedMesh.count) {
              instancedMesh.setColorAt(selectedPointIndex, colorArray[selectedPointIndex]);
            }
            
            // Update selected point ID and index
            selectedPointId = pointId;
            selectedPointIndex = index;
            
            // Highlight the selected point
            instancedMesh.setColorAt(index, selectedColor);
            instancedMesh.instanceColor.needsUpdate = true;
            
            // Get position from instancedMesh's matrix
            const matrix = new THREE.Matrix4();
            instancedMesh.getMatrixAt(index, matrix);
            selectedPointPosition = new THREE.Vector3();
            selectedPointPosition.setFromMatrixPosition(matrix);
            
            // Update the selected point display
            updateSelectedPointDisplay();
            
            // Update distance line and display
            updateDistanceLineAndDisplay();
          }
        }
      }

      function checkIntersections() {
        // Only continue if we have instancedMesh set up
        if (!instancedMesh || instancedMesh.count === 0) return;
        
        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObject(instancedMesh);
        
        if (intersects.length > 0) {
          // Get the instance index
          const index = intersects[0].instanceId;
          
          // Skip if this is the selected point
          if (index === selectedPointIndex) {
            // Hide hover effects when hovering over selected point
            if (prevHoverIndex !== -1 && prevHoverIndex !== selectedPointIndex && prevHoverIndex < instancedMesh.count) {
              instancedMesh.setColorAt(prevHoverIndex, colorArray[prevHoverIndex]);
              instancedMesh.instanceColor.needsUpdate = true;
            }
            prevHoverIndex = -1;
            labelDiv.style.display = "none";
            formulaTextDiv.style.display = "none";
            hoverPointPosition = null;
            updateDistanceLineAndDisplay();
            return;
          }
          
          // Highlight point and show label
          if (index !== prevHoverIndex) {
            // Reset previous hover
            if (prevHoverIndex !== -1 && prevHoverIndex !== selectedPointIndex && prevHoverIndex < instancedMesh.count) {
              instancedMesh.setColorAt(prevHoverIndex, colorArray[prevHoverIndex]);
            }
            
            // Set new hover color
            instancedMesh.setColorAt(index, hoverColor);
            instancedMesh.instanceColor.needsUpdate = true;
            prevHoverIndex = index;
          }
          
          updateLabel(index);
        } else {
          // Reset hover state when no intersection
          if (prevHoverIndex !== -1 && prevHoverIndex !== selectedPointIndex && prevHoverIndex < instancedMesh.count) {
            instancedMesh.setColorAt(prevHoverIndex, colorArray[prevHoverIndex]);
            instancedMesh.instanceColor.needsUpdate = true;
            prevHoverIndex = -1;
          }
          
          labelDiv.style.display = "none";
          formulaTextDiv.style.display = "none";
          hoverPointPosition = null;
          updateDistanceLineAndDisplay();
        }
      }

      // --- Update InstancedMesh from CSV Data ---
      function updatePointsFromCSV(csvData) {
        count = csvData.length;
        pointData = csvData;
        
        // Reset selected point data
        selectedPointId = null;
        selectedPointIndex = -1;
        selectedPointPosition = null;
        hoverPointPosition = null;
        distanceLine.visible = false;
        distanceDisplayDiv.style.display = "none";
        
        // Remove previous instancedMesh if exists
        if (instancedMesh) {
          scene.remove(instancedMesh);
        }
        
        // Choose geometry based on rendering mode
        const geometry = renderAsSpheres ? sphereGeometry : planeGeometry;
        
        // Create new instancedMesh with correct count
        instancedMesh = new THREE.InstancedMesh(geometry, instanceMaterial, count);
        scene.add(instancedMesh);
        
        // Store original colors
        colorArray = new Array(count);
        
        // Set up dummy object for matrix calculations
        const dummy = new THREE.Object3D();
        
        for (let i = 0; i < count; i++) {
          const pt = csvData[i];
          
          // Parse coordinates
          const x = parseFloat(pt.x) || 0;
          const y = parseFloat(pt.y) || 0;
          const z = parseFloat(pt.z) || 0;
          
          // Position the dummy
          dummy.position.set(x, y, z);
          
          if (!renderAsSpheres) {
            // Make plane always face the camera by rotating it to camera
            dummy.lookAt(camera.position);
          }
          
          // Update matrix
          dummy.updateMatrix();
          instancedMesh.setMatrixAt(i, dummy.matrix);
          
          // Handle color from cluster color
          let color;
          if (pt.color) {
            color = new THREE.Color(pt.color);
          } else {
            color = defaultColor.clone();
          }
          
          // Store original color
          colorArray[i] = color.clone();
          
          // Set color
          instancedMesh.setColorAt(i, color);
        }
        
        instancedMesh.instanceMatrix.needsUpdate = true;
        if (instancedMesh.instanceColor) instancedMesh.instanceColor.needsUpdate = true;
        
        // Hide loading message once data is loaded
        loadingMessageDiv.style.display = "none";
      }

      // --- Fetch CSV from URL ---
      async function fetchCSV(url) {
        try {
          const response = await fetch(url);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const text = await response.text();
          return parseCSV(text);
        } catch (error) {
          console.error(`Error fetching ${url}:`, error);
          return null;
        }
      }

      // --- Load Default Data ---
      async function loadDefaultData() {
        loadingMessageDiv.style.display = "block";
        
        try {
          // Load coordinates CSV
          const pointsData = await fetchCSV(DEFAULT_POINTS_URL);
          if (pointsData) {
            updatePointsFromCSV(pointsData);
          } else {
            throw new Error("Failed to load default points data");
          }
          
          // Load formulas CSV
          const formulas = await fetchCSV(DEFAULT_FORMULAS_URL);
          if (formulas) {
            formulasData = formulas;
            console.log("Default formulas loaded:", formulasData.length);
          } else {
            console.warn("Failed to load default formulas data");
          }
        } catch (error) {
          console.error("Error loading default data:", error);
          // Create fallback sample data if default loading fails
          createSampleData();
        } finally {
          loadingMessageDiv.style.display = "none";
        }
      }

      // Create sample data as fallback
      function createSampleData() {
        console.log("Creating sample data as fallback");
        const sampleData = [];
        for (let i = 0; i < 50; i++) {
          const cluster = Math.floor(Math.random() * 5);
          const clusterColors = [
            "#ff0000", "#00ff00", "#0000ff", "#ffff00", "#ff00ff"
          ];
          
          sampleData.push({
            id: `Point ${i+1}`,
            x: (Math.random() - 0.5) * 30,
            y: (Math.random() - 0.5) * 30,
            z: (Math.random() - 0.5) * 30,
            cluster: cluster,
            color: clusterColors[cluster]
          });
        }
        
        // Create sample formula data
        formulasData = [];
        for (let i = 0; i < 50; i++) {
          formulasData.push({
            id: `Point ${i+1}`,
            text: `This is the detailed information for Point ${i+1}. It belongs to cluster ${Math.floor(Math.random() * 5)}. Click on this point to pin this text to the right panel.`
          });
        }
        
        updatePointsFromCSV(sampleData);
      }

      // --- File Input to Load CSV Data ---
      const csvInput = document.getElementById("csvInput");
      csvInput.addEventListener("change", (event) => {
        const file = event.target.files[0];
        if (file) {
          loadingMessageDiv.style.display = "block";
          loadingMessageDiv.textContent = `Loading ${file.name}...`;
          
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const csvData = parseCSV(e.target.result);
              updatePointsFromCSV(csvData);
            } catch (err) {
              console.error("Error parsing CSV:", err);
              alert("Error parsing CSV file. Please check console for details.");
              loadingMessageDiv.style.display = "none";
            }
          };
          reader.readAsText(file);
        }
      });

      // --- File Input to Load Formulas CSV ---
      const formulasInput = document.getElementById("formulasInput");
      formulasInput.addEventListener("change", (event) => {
        const file = event.target.files[0];
        if (file) {
          loadingMessageDiv.style.display = "block";
          loadingMessageDiv.textContent = `Loading ${file.name}...`;
          
          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              formulasData = parseCSV(e.target.result);
              console.log("Formulas loaded:", formulasData.length);
              
              // Update selected point display if needed
              if (selectedPointId) {
                updateSelectedPointDisplay();
              }
              
              loadingMessageDiv.style.display = "none";
            } catch (err) {
              console.error("Error parsing formulas CSV:", err);
              alert("Error parsing formulas CSV file. Please check console for details.");
              loadingMessageDiv.style.display = "none";
            }
          };
          reader.readAsText(file);
        }
      });

      // --- Toggle between Planes and Spheres ---
      const renderAsSpheresCheckbox = document.getElementById("renderAsSpheres");
      renderAsSpheresCheckbox.checked = renderAsSpheres;
      renderAsSpheresCheckbox.addEventListener("change", (event) => {
        renderAsSpheres = event.target.checked;
        
        // Re-create the points with the new geometry
        if (pointData) {
          updatePointsFromCSV(pointData);
        }
      });

      // --- Keyboard Controls for Panning ---
      const keySpeed = 1;
      document.addEventListener('keydown', (event) => {
        switch(event.key) {
          case 'ArrowLeft':
            controls.pan(keySpeed, 0);
            break;
          case 'ArrowRight':
            controls.pan(-keySpeed, 0);
            break;
          case 'ArrowUp':
            controls.pan(0, keySpeed);
            break;
          case 'ArrowDown':
            controls.pan(0, -keySpeed);
            break;
        }
      });

      // --- Make planes face camera when camera moves ---
      controls.addEventListener('change', () => {
        if (instancedMesh && instancedMesh.count > 0 && !renderAsSpheres) {
          const dummy = new THREE.Object3D();
          
          for (let i = 0; i < instancedMesh.count; i++) {
            // Get current position from matrix
            const matrix = new THREE.Matrix4();
            instancedMesh.getMatrixAt(i, matrix);
            const position = new THREE.Vector3();
            position.setFromMatrixPosition(matrix);
            
            // Position the dummy at that position
            dummy.position.copy(position);
            
            // Make it look at camera
            dummy.lookAt(camera.position);
            
            // Update matrix
            dummy.updateMatrix();
            instancedMesh.setMatrixAt(i, dummy.matrix);
          }
          
          instancedMesh.instanceMatrix.needsUpdate = true;
        }
        
        // Update distance line and display if applicable
        if (selectedPointPosition && hoverPointPosition) {
          updateDistanceLineAndDisplay();
        }
      });

      // Initialize with sample data
      createSampleData();

      // Add event listeners
      renderer.domElement.addEventListener("pointermove", onPointerMove);
      renderer.domElement.addEventListener("pointerdown", onPointerDown);

      // --- Animation Loop ---
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      // --- Responsive Resize ---
      window.addEventListener("resize", () => {
        const width = window.innerWidth;
        const height = window.innerHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
        
        // Update distance line and display if applicable
        if (selectedPointPosition && hoverPointPosition) {
          updateDistanceLineAndDisplay();
        }
      });
    </script>
  </body>
</html>
